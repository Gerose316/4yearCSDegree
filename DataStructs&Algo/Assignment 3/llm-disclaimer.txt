I used chat GPT for problems j and problems I 

I used chat GPT for problems I since I tried to implement a solution, and that program wanted a push_middle of o(1) in, which I could provide since the program in question is not fast enough 
for the standard of the programming question which at the end of the program relied on a stl implementation of deque and kept the original class I used and solved the question with the assistance 
of LLM


#problem j

for problem J it was completely different different I used llm in the aspect of the class deque and asked llm for an exact replica of the stl implementation of the deque in order to the foosball dynasty
I saw various ideas from ChatGPT and implemented time playing unordered map, which worked perfectly compared to my other submission, which passed only the test case 2/25 and never worked 
so I combine the code from the TA in lab, the original code that I had before lab, and the llm solution, which I mixed all the terminology which led to the correct solution to the foosball dynasty program




problems a-j I used some portions of the code with LLM, and it was only for time-saving purposes. Problem A, problem b, and problem I stack , queue, and deque are the same that is implemented in the other issues which I reused some code 
to make sense of the code.


for example I used 

#include <iostream>

class queue{
    private:
        int *array;
        int length; 
        int front;
        int count;
        int base;
    public:
        queue(int len);
        ~queue();
        void enqueue(int);
        int dequeue();
        int severResponse();
    

};

queue::queue(int len){
    length = len;
    array = new int[length];
    front = 0;
    count = 0;
    base = 0;
}

queue::~queue(){
    delete [] array;
}

void queue::enqueue(int value){
    if(count == length){
        throw std::out_of_range("full");
    } 
        array[base] = value;
        base = (base + 1) % length;
        count++;
    
}

int queue::dequeue(){
    if(count == 0){
        throw std::out_of_range("empty");
    } else {
        int val = array[front];
        front = (front + 1) % length;
        count--;
        return val;
    }
}
 

in programs a and program e 

this same applies for programs b 


// fixed-length array (not a dynamic array)
class Stack {
    private:
    // array to store stack elements
    char* array;
    // maximum number of elements stack can hold
    size_t length;
    // current number of elements in stack
    size_t top;

    int *index;
   
   
    public:
    Stack(int);
    ~Stack();
    // pushes an element onto the stack
    void push(char val, int pos);
    // returns/removes the top element from the stack
    char pop(int &pos);

    bool ismatchingPair(char open, char close);
    void isBalanced(std::string,int);
    
    




   };

 
   Stack::Stack(int len) {
    length = len;
    array = new char[length];
    index = new int[length];
    top = 0;
   }

   Stack::~Stack() {
    delete [] array;
    delete[] index;

   }

   void Stack::push(char val,int pos ) {
   if (top < length - 1) {
         array[++top] = val;
         index[top] = pos;

    }
   }



   bool Stack::ismatchingPair(char open, char close){
    return (open == '(' && close == ')') ||
           (open == '{' && close == '}') ||
           (open == '[' && close == ']');

   }

char Stack::pop(int &pos) {
  if (top >= 0) {
        pos = index[top];
        return array[top--];
    }
    return '0';
   }


I used this for programs C,D,F,G which this code I used is ai generated by code pilot but only wanted to use the class to advance further into the progreaming queastiopn